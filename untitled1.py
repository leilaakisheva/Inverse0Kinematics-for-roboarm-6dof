# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ombMEviki9GGqEiVp-6qlw8QGW1NlC00
"""

import numpy as np

L0=7.2
L1=19.5
L2=31.8
L3=18.25
L4=29.5

x=31
y=20
z=20

theta1=np.arctan2(y, x)
d= np.sqrt(x**2+z**2)
a=d-L0
b=z-L1
c=np.sqrt(a**2+b**2)

theta3= np.arccos((L2**2+c**2-L3**2)/(2*L2*c))
alpha= np.arccos((L2**2+c**2-L3**2)/(2*L2*c))
beta= np.arccos((L2**2+L3**2-c**2)/(2*L2*L3))
gamma= np.arccos((L3**2+c**2-L2**2)/(2*L3*c))

theta2 = np.arctan2(b, a)-alpha
theta4 = np.pi-beta
theta5 = np.pi-(gamma+theta3)

end_effector_pos = np.array([L0 * np.cos(theta1) + L1 * np.cos(theta1) * np.cos(theta2) + L2 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) + L3 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5),
                            L0 * np.sin(theta1) + L1 * np.sin(theta1) * np.cos(theta2) + L2 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) + L3 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5),
                            L1 * np.sin(theta2) + L2 * np.sin(theta2) * np.cos(theta3) + L3 * np.sin(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.sin(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5)])

end_effector_orient = np.array([[np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.cos(theta5) - np.sin(theta1) * np.sin(theta5), -np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.sin(theta4) - np.cos(theta1) * np.sin(theta2) * np.cos(theta4) * np.cos(theta5), -np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5)],
                                [np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.cos(theta5) + np.cos(theta1) * np.sin(theta5), -np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.sin(theta4) - np.sin(theta1) * np.sin(theta2) * np.cos(theta4) * np.cos(theta5), -np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5)],
                                [np.sin(theta2) * np.cos(theta3) * np.cos(theta4) * np.cos(theta5), -np.sin(theta2) * np.cos(theta3) * np.sin(theta4) + np.cos(theta2) * np.cos(theta4) * np.cos(theta5), -np.sin(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5)]])

import math
# Calculate the end effector orientation using the rotation matrices
rot_mat_0_1 = np.array([[np.cos(theta1), 0, np.sin(theta1)],
                        [np.sin(theta1), 0, -np.cos(theta1)],
                        [0, 1, 0]])
rot_mat_1_2 = np.array([[np.cos(theta2), -np.sin(theta2), 0],
                        [np.sin(theta2), np.cos(theta2), 0],
                        [0, 0, 1]])
rot_mat_2_3 = np.array([[np.cos(theta3), -np.sin(theta3), 0],
                        [np.sin(theta3), np.cos(theta3), 0],
                        [0, 0, 1]])
rot_mat_3_4 = np.array([[-np.sin(theta4), 0, np.cos(theta4)],
                        [np.cos(theta4), 0, np.sin(theta4)],
                        [0, 1, 0]])
rot_mat_4_5 = np.array([[np.cos(theta5), -np.sin(theta5), 0],
                        [np.sin(theta5), np.cos(theta5), 0],
                        [0, 0, 1]])

# Calculate the rotation matrix that converts the end effector frame (frame 5) to the servo_0 frame.
rot_mat_0_5 = rot_mat_0_1 @ rot_mat_1_2 @ rot_mat_2_3 @ rot_mat_3_4 @ rot_mat_4_5

def isRotationMatrix(R) :
    Rt = np.transpose(R)
    shouldBeIdentity = np.dot(Rt, R)
    I = np.identity(3, dtype = R.dtype)
    n = np.linalg.norm(I - shouldBeIdentity)
    return n < 1e-6
isRotationMatrix(rot_mat_0_5)
def rotationMatrixToEulerAngles(R) :

    assert(isRotationMatrix(R))

    sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])

    singular = sy < 1e-6

    if  not singular :
        x = math.atan2(R[2,1] , R[2,2])
        y = math.atan2(-R[2,0], sy)
        z = math.atan2(R[1,0], R[0,0])
    else :
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0

    return np.array([x, y, z])
rotationMatrixToEulerAngles(rot_mat_0_5)
def get_wrist_center(gripper_point, R0g, dg = 0.303):
  # get the coordinates of the wrist center wrt to the base frame (xw, yw, zw)
  # given the following info:
  # the coordinates of the gripper (end effector) (x, y, z)
  # the rotation of the gripper in gripper frame wrt to the base frame (R0u)
  # the distance between gripper and wrist center dg which is along common z axis
  # check WRITEUP.pdf for more info
  xu, yu, zu = gripper_point

  nx, ny, nz = R0g[0, 2], R0g[1, 2], R0g[2, 2]
  xw = xu - dg * nx
  yw = yu - dg * ny
  zw = zu - dg * nz

  return xw, yw, zw

print("Joint angles:")
print("Theta1:", np.degrees(theta1))
print("Theta2:", np.degrees(theta2))
print("Theta3:", np.degrees(theta3))
print("Theta4:", np.degrees(theta4))
print("Theta5:", np.degrees(theta5))

print("\nDesired end effector position:")
print("X:",x)
print("Y:", y)
print("Z:", z)

print("\nCalculated end effector position:")
print("X:", end_effector_pos[0])
print("Y:", end_effector_pos[1])
print("Z:", end_effector_pos[2])

print("\nCalculated end effector orientation:")
print(end_effector_orient)
print("\nCalculated rot matrix 0-5:")
print(rot_mat_0_5)

import numpy as np

def inverse_kinematics(x, y, z):
    # Define the lengths of the line segments
    L0 = 7.2
    L1 = 19.5
    L2 = 31.8
    L3 = 18.25
    L4 = 29.5

    # Calculate the joint angles theta1, theta2, and theta3
    theta1 = np.arctan2(y, x)
    D = (x**2 + y**2 + (z - L0)**2 - L1**2 - L2**2 - L3**2 - L4**2) / (2 * L2 * np.sqrt(L3**2 + L4**2))
    theta3 = np.arctan2(np.sqrt(1 - D**2), D)
    theta2 = np.arctan2(z - L0, np.sqrt(x**2 + y**2)) - np.arctan2(L4 * np.sin(theta3), L3 + L4 * np.cos(theta3))

    # Calculate the end effector orientation using the rotation matrices
    rot_mat_0_1 = np.array([[np.cos(theta1), 0, np.sin(theta1)],
                            [np.sin(theta1), 0, -np.cos(theta1)],
                            [0, 1, 0]])
    rot_mat_1_2 = np.array([[np.cos(theta2), -np.sin(theta2), 0],
                            [np.sin(theta2), np.cos(theta2), 0],
                            [0, 0, 1]])
    rot_mat_2_3 = np.array([[np.cos(theta3), -np.sin(theta3), 0],
                            [np.sin(theta3), np.cos(theta3), 0],
                            [0, 0, 1]])
    rot_mat_3_4 = np.array([[-np.sin(theta4), 0, np.cos(theta4)],
                            [np.cos(theta4), 0, np.sin(theta4)],
                            [0, 1, 0]])
    rot_mat_4_5 = np.array([[np.cos(theta5), -np.sin(theta5), 0],
                            [np.sin(theta5), np.cos(theta5), 0],
                            [0, 0, 1]])
    # Calculate the rotation matrix that converts the end effector frame (frame 5) to the base frame (frame 0)
    rot_mat_0_5 = rot_mat_0_1 @ rot_mat_1_2 @ rot_mat_2_3 @ rot_mat_3_4 @ rot_mat_4_5

    # Calculate theta4 and theta5
    theta4 = np.arctan2(rot_mat_3_4[0, 2], rot_mat_3_4[2, 2])
    theta5 = np.arctan2(rot_mat_4_5[1, 0], rot_mat_4_5[1, 1])

    # Return the joint angles theta1, theta2, theta3, theta4, and theta5
    return theta1, theta2, theta3, theta4, theta5

# Example usage
x = 10
y = 20
z = 30

theta1, theta2, theta3, theta4, theta5 = inverse_kinematics(x, y, z)
print("Theta 1:", theta1)
print("Theta 2:", theta2)
print("Theta 3:", theta3)
print("Theta 4:", theta4)
print("Theta 5:", theta5)

def forward_kinematics(theta1, theta2, theta3, theta4, theta5):
    end_effector_pos = np.array([L0 * np.cos(theta1) + L1 * np.cos(theta1) * np.cos(theta2) + L2 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) + L3 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.cos(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5),
                                L0 * np.sin(theta1) + L1 * np.sin(theta1) * np.cos(theta2) + L2 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) + L3 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.sin(theta1) * np.cos(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5),
                                L1 * np.sin(theta2) + L2 * np.sin(theta2) * np.cos(theta3) + L3 * np.sin(theta2) * np.cos(theta3) * np.cos(theta4) + L4 * np.sin(theta2) * np.cos(theta3) * np.cos(theta4) * np.sin(theta5)])

    return end_effector_pos
x,y,z=forward_kinematics()